// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{EDAG_VERIFY_ELF, EDAG_VERIFY_ID};

use edag_verify_core::{CertificateChain, CertificateChainNode, DagGraph, VerificationResult};
use k256::ecdsa::{signature::Signer, Signature, SigningKey, VerifyingKey};
use k256::sha2::{Digest, Sha256};
use rand_core::OsRng;
use risc0_zkvm::{default_prover, ExecutorEnv, Receipt};
use serde_json::to_string;
use serde_yaml;
use std::{env, fs::File, io::Read};

fn load_dag(yaml_path: &str) -> DagGraph {
    let mut file = File::open(yaml_path).expect("tlessctl(verify): failed to load yaml path");
    let mut contents = String::new();
    file.read_to_string(&mut contents)
        .expect("tlessctl(verify): faild to read yaml");
    let dag: DagGraph =
        serde_yaml::from_str(&contents).expect("tlessctl(verify): failed to parse yaml");

    dag
}

/// Given an input DAG, and a CertificateChain, this function generates a
/// Receipt that the guest executed the requested program, with the reults
/// committed to the execution journal
fn verify_edag(
    cert_chain: &CertificateChain,
    dag: &DagGraph,
    verifying_key: &VerifyingKey,
    // These values is just for the microbenchmark
    num_chains: i32,
    skip_verify: bool,
) -> Receipt {
    let input = (
        dag,
        cert_chain,
        verifying_key.to_encoded_point(true),
        num_chains,
        skip_verify,
    );
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Produce a receipt by proving the specified ELF binary.
    prover.prove(env, EDAG_VERIFY_ELF).unwrap().receipt
}

fn main() {
    // Read the experiment parameters from the command line
    let args: Vec<_> = env::args().collect();
    if args.len() != 3 {
        panic!("usage: <skip_verify> <num_parallel_chains>");
    }
    let skip_verify: bool = args[1].parse::<i32>().unwrap() == 1;
    let num_chains: i32 = args[2].parse().unwrap();

    // Generate a random secp256k1 keypair and sign the message.
    let signing_key = SigningKey::random(&mut OsRng); // Serialize with `::to_bytes()`

    // FIXME(tless-prod): do not manually generate a certificate chain here
    let funcs = vec![
        CertificateChainNode::new_from_str("splitter", "my-hexstring-of-hw-att-1"),
        CertificateChainNode::new_from_str("mapper", "my-hexstring-of-hw-att-2"),
        CertificateChainNode::new_from_str("reducer", "my-hexstring-of-hw-att-3"),
    ];
    let funcs_json =
        to_string(&funcs).expect("tlessctl(verify): failed to serialize nodes to json");
    let mut hasher = Sha256::new();
    hasher.update(funcs_json.as_bytes());
    let funcs_hash = hasher.finalize();
    let signature: Signature = signing_key.sign(funcs_hash.as_slice());
    let cert_chain = CertificateChain::new(funcs, signature);

    // Load DAG
    let dag = load_dag("./test_dag.yaml");

    // Run signature verified in the zkVM guest and get the resulting receipt
    // TODO: ideally, we would pass an array of cert_chains corresponding to
    // leafs in the eDag
    let receipt = verify_edag(
        &cert_chain,
        &dag,
        signing_key.verifying_key(),
        num_chains,
        skip_verify,
    );

    // FIXME(tless-prod): this receipt is what we should return to the user.
    // Verification should happen on the user side, not the cloud provider
    receipt.verify(EDAG_VERIFY_ID).unwrap();

    // Output:
    // - DAG digest
    // - Signature verification result
    // - Function chain verification result
    let result: VerificationResult = receipt.journal.decode().unwrap();

    println!(
        "Signature valid: {} - DAG preserved: {}",
        result.signature_valid, result.dag_preserved
    );
}
